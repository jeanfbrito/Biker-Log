name: Android CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

env:
  JAVA_VERSION: '17'
  JAVA_DISTRIBUTION: 'temurin'

jobs:
  lint:
    name: Lint Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: ${{ env.JAVA_DISTRIBUTION }}
        cache: gradle
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.android/build-cache
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Clear corrupted jars
      run: rm -rf ~/.gradle/caches/jars-9/
      continue-on-error: true
    
    - name: Run Android Lint
      run: ./gradlew lint --build-cache --parallel
    
    - name: Upload lint results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: lint-results
        path: app/build/reports/lint-results-*.html
        retention-days: 7

  # Unit tests temporarily disabled - need proper mocking
  # unit-test:
  #   name: Unit Tests
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 20

  build:
    name: Build APK
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [lint]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: ${{ env.JAVA_DISTRIBUTION }}
        cache: gradle
    
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.android/build-cache
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    - name: Cache build outputs
      uses: actions/cache@v4
      with:
        path: |
          app/build
          build
        key: ${{ runner.os }}-build-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-build-
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Build debug APK
      run: ./gradlew assembleDebug --build-cache --parallel --stacktrace
    
    - name: Upload debug APK
      uses: actions/upload-artifact@v4
      with:
        name: debug-apk
        path: app/build/outputs/apk/debug/app-debug.apk
        retention-days: 7
    
    - name: Build release APK
      run: ./gradlew assembleRelease --build-cache --parallel --stacktrace
    
    - name: Upload release APK
      uses: actions/upload-artifact@v4
      with:
        name: release-apk
        path: app/build/outputs/apk/release/app-release-unsigned.apk
        retention-days: 7

  analyze:
    name: Code Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: ${{ env.JAVA_DISTRIBUTION }}
        cache: gradle
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Check for hardcoded secrets
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: ${{ github.event.pull_request.base.sha }}
        head: ${{ github.event.pull_request.head.sha }}
    
    - name: Run dependency check
      run: ./gradlew dependencyCheckAnalyze || true
      continue-on-error: true
    
    - name: Check for outdated dependencies
      run: ./gradlew dependencyUpdates -Drevision=release
      continue-on-error: true

  validate-pr:
    name: PR Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - name: Check PR title
      uses: amannn/action-semantic-pull-request@v6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        types: |
          feat
          fix
          docs
          style
          refactor
          perf
          test
          chore
          revert
        requireScope: false
    
    - name: Check for CHANGELOG entry
      if: github.event.pull_request.draft == false
      run: |
        if ! grep -q "## \[Unreleased\]" CHANGELOG.md 2>/dev/null; then
          echo "::warning::No CHANGELOG.md found or no [Unreleased] section"
        fi
    
    - name: Label PR
      uses: actions/labeler@v4
      with:
        repo-token: "${{ secrets.GITHUB_TOKEN }}"

  comment-results:
    name: Comment PR Results
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && always()
    needs: [lint, build, analyze]
    
    steps:
    - name: Comment PR
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const issue_number = context.issue.number;
          const run_id = context.runId;
          
          // Get job results from needs context
          const needs = ${{ toJson(needs) }};
          
          // Create status icons
          const getIcon = (status) => {
            switch(status) {
              case 'success': return 'âœ…';
              case 'failure': return 'âŒ';
              case 'cancelled': return 'âš ï¸';
              case 'skipped': return 'â­ï¸';
              default: return 'â³';
            }
          };
          
          // Get artifacts if build succeeded
          let artifactsSection = '';
          if (needs.build?.result === 'success') {
            try {
              const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
                owner,
                repo,
                run_id,
              });
              
              const apkArtifacts = artifacts.artifacts.filter(a => a.name.includes('apk'));
              
              if (apkArtifacts.length > 0) {
                artifactsSection = `
          
          ### ðŸ“± APK Downloads
          
          `;
                for (const artifact of apkArtifacts) {
                  const sizeMB = (artifact.size_in_bytes / 1048576).toFixed(1);
                  const downloadUrl = `https://github.com/${owner}/${repo}/actions/runs/${run_id}/artifacts/${artifact.id}`;
                  artifactsSection += `- **[${artifact.name}](${downloadUrl})** (${sizeMB} MB)\n`;
                }
                artifactsSection += `
          
          > ðŸ“Œ Note: You must be logged in to GitHub to download artifacts
          `;
              }
            } catch (error) {
              console.log('Error fetching artifacts:', error.message);
            }
          }
          
          // Build comment body
          const body = `## CI Results
          
          | Check | Status |
          |-------|--------|
          | Lint | ${getIcon(needs.lint?.result || 'pending')} |
          | Build | ${getIcon(needs.build?.result || 'pending')} |
          | Code Analysis | ${getIcon(needs.analyze?.result || 'pending')} |
          ${artifactsSection}
          
          [View full CI logs](${context.payload.pull_request.html_url}/checks)
          
          ---
          <sub>ðŸ¤– Generated by GitHub Actions</sub>`;
          
          try {
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## CI Results')
            );
            
            // Update or create comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
            }
          } catch (error) {
            console.log('Error posting comment:', error.message);
            // Don't fail the workflow if commenting fails
          }